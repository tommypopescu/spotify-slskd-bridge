{% extends "base.html" %}
{% block content %}

<!-- =============== Exportify (fără iframe) =============== -->
<section style="margin:1rem 0; padding:1rem; border:1px solid #22304b; border-radius:.6rem; background:#0e1726">
  <h2 style="margin-top:0">Exportă playlist cu Exportify</h2>
  <p style="opacity:.85; margin-bottom:.5rem">
    1) Deschide Exportify → apasă <strong>Export</strong> → se descarcă CSV.<br>
    2) Încarcă fișierul CSV mai jos.
  </p>

  <p style="margin:.25rem 0;">
    <a href="https://exportify.app/" target="_blank" rel="noopener"
       style="padding:.45rem .7rem; border:1px solid #334155; border-radius:.45rem; background:#1f2a44; color:#e6eefc; text-decoration:none;">
      Deschide Exportify în tab nou
    </a>
  </p>

  <hr style="border:none;border-top:1px solid #22304b;margin:1rem 0"/>

  <!-- =============== Upload CSV (FORMULAR CORECT) =============== -->
  <form action="/upload" method="POST" enctype="multipart/form-data" style="margin:0;">
    <label for="playlist_file" style="white-space:nowrap; margin-right:.25rem;">CSV din Exportify:</label>
    <input type="file" id="playlist_file" name="playlist_file" accept=".csv,text/csv"
           style="padding:.35rem .5rem; border:1px solid #334155; border-radius:.35rem; background:#0e1726; color:#e6eefc;"
           required />
    <button type="submit"
            style="padding:.5rem .8rem; border:1px solid #334155; border-radius:.5rem; background:#1f2a44; color:#e6eefc; cursor:pointer;">
      Încarcă playlist
    </button>
  </form>
</section>

{% if error %}
  <div class="error">Eroare: {{ error }}</div>
{% endif %}

{% if tracks and not error %}
  <!-- JSON (opțional pentru export) -->
  <script id="tracks-data" type="application/json">
    {{ tracks | tojson }}
  </script>

  <!-- ===== Toolbar rezultate ===== -->
  <div style="display:flex; align-items:center; gap:.75rem; flex-wrap:wrap; margin:.75rem 0;">
    <strong>Piese:</strong> {{ tracks|length }}

    <!-- Filtru live -->
    <input id="filterBox"
           placeholder="Filtrează piese (titlu / artiști / query)…"
           style="padding:.35rem .6rem; border:1px solid #334155; border-radius:.4rem; background:#0e1726; color:#e6eefc; min-width:260px;" />

    <!-- Descarcă CSV -->
    <button id="downloadCsvBtn"
            style="padding:.35rem .6rem; border:1px solid #334155; border-radius:.4rem; background:#1f2a44; color:#e6eefc; cursor:pointer;">
      Descarcă CSV
    </button>

    <!-- Select all / clear -->
    <button id="selectAllBtn"
            style="padding:.35rem .6rem; border:1px solid #334155; border-radius:.4rem; background:#18223b; color:#e6eefc; cursor:pointer;">
      Selectează toate
    </button>
    <button id="clearAllBtn"
            style="padding:.35rem .6rem; border:1px solid #334155; border-radius:.4rem; background:#18223b; color:#e6eefc; cursor:pointer;">
      Deselectează toate
    </button>

    <!-- Batch (10s) -->
    <button id="searchSelectedBtn"
            style="padding:.35rem .6rem; border:1px solid #334155; border-radius:.4rem; background:#0f3d2e; color:#e6eefc; cursor:pointer;">
      Caută selectate (10s)
    </button>

    <span id="batchStatus" style="opacity:.8"></span>
  </div>

  <!-- ===== Lista pieselor ===== -->
  <ul class="tracklist" id="tracklist" style="padding:0; list-style:none;">
    {% for t in tracks %}
    <li class="track-row"
        data-title="{{ t.title|e }}"
        data-artists="{{ t.artists|e }}"
        data-query="{{ t.query|e }}"
        style="padding:.55rem 0; border-bottom:1px solid #334155; display:flex; align-items:center; gap:.6rem;">
      <!-- Checkbox -->
      <input type="checkbox"
             class="sel"
             data-query="{{ t.query|e }}"
             value="{{ t.query|e }}"
             style="transform:translateY(1px);" />

      <!-- Text melodie -->
      <div class="meta" style="min-width:0; flex:1 1 auto;">
        <span class="title" style="display:block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
          {{ t.title }}
        </span>
        <span class="artists" style="opacity:.8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
          {{ t.artists }}
        </span>
      </div>

      <!-- Buton Caută lipit de text + ✔️ după succes -->
      <div class="actions" style="flex:0 0 auto; display:flex; align-items:center; gap:.5rem;">
        <button class="one-search-btn"
                style="padding:.3rem .55rem; border:1px solid #334155; border-radius:.4rem; background:#1f2a44; color:#e6eefc; cursor:pointer;">
          Caută
        </button>
        <span class="mark" style="display:none; color:#34d399; font-size:1.1rem; font-weight:700;">✔️</span>
      </div>
    </li>
    {% endfor %}
  </ul>
{% endif %}

<!-- =============== Scripturi =============== -->
<script>
(function(){
  const STORAGE_KEY = 'slskd-selected';

  // --- Utils: selecție persistată ---
  function getSaved(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); } catch(_) { return []; } }
  function saveSelection(){
    const selected = Array.from(document.querySelectorAll('.sel'))
      .filter(cb => cb.checked)
      .map(cb => cb.getAttribute('data-query') || cb.value);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(selected));
  }
  function restoreSelection(){
    const saved = getSaved();
    document.querySelectorAll('.sel').forEach(cb => {
      const q = cb.getAttribute('data-query') || cb.value;
      if (saved.includes(q)) cb.checked = true;
    });
  }

  // --- Elemente UI ---
  const tracklist   = document.getElementById('tracklist');
  const filterBox   = document.getElementById('filterBox');
  const btnDownload = document.getElementById('downloadCsvBtn');
  const btnSelAll   = document.getElementById('selectAllBtn');
  const btnClrAll   = document.getElementById('clearAllBtn');
  const btnBatch    = document.getElementById('searchSelectedBtn');
  const statusEl    = document.getElementById('batchStatus');

  // --- Filtru live ---
  function applyFilter(){
    if(!tracklist) return;
    const term = (filterBox?.value || '').trim().toLowerCase();
    tracklist.querySelectorAll('.track-row').forEach(li => {
      const t = (li.dataset.title   || '').toLowerCase();
      const a = (li.dataset.artists || '').toLowerCase();
      const q = (li.dataset.query   || '').toLowerCase();
      li.style.display = (t.includes(term) || a.includes(term) || q.includes(term)) ? 'flex' : 'none';
    });
  }
  filterBox && filterBox.addEventListener('input', applyFilter);

  // --- Download CSV (din DOM) ---
  btnDownload && btnDownload.addEventListener('click', ()=>{
    const rows = Array.from(document.querySelectorAll('.track-row .meta')).map(meta => {
      const title   = meta.querySelector('.title')?.textContent?.trim()   || '';
      const artists = meta.querySelector('.artists')?.textContent?.trim() || '';
      const query   = artists ? (artists + ' - ' + title) : title;
      return [title, artists, query];
    });
    if(!rows.length){ alert('Nu există piese.'); return; }

    const header = ['Track Name','Artist Name(s)','Query'];
    const all = [header, ...rows];
    const csv = all.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\r\n');

    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href = url; a.download = 'playlist_curent.csv';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

  // --- Select all / clear all ---
  btnSelAll && btnSelAll.addEventListener('click', ()=>{
    if(!tracklist) return;
    tracklist.querySelectorAll('.sel:not(:disabled)').forEach(cb => cb.checked = true);
    saveSelection();
  });
  btnClrAll && btnClrAll.addEventListener('click', ()=>{
    if(!tracklist) return;
    tracklist.querySelectorAll('.sel:not(:disabled)').forEach(cb => cb.checked = false);
    saveSelection();
  });

  // --- Click individual pe "Caută" (delegare pe listă) ---
  if(tracklist){
    tracklist.addEventListener('click', async (ev)=>{
      const btn = ev.target.closest('.one-search-btn');
      if(!btn) return;

      const li = btn.closest('.track-row');
      const q  = li?.dataset?.query || '';
      if(!q){ alert('Query lipsă.'); return; }

      btn.disabled = true;
      try{
        const resp = await fetch('/slskd/search', {
          method: 'POST',
          headers: { 'Content-Type':'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ q })
        });
        const json = await resp.json();
        if(json && json.ok){
          const cb   = li.querySelector('.sel');
          const mark = li.querySelector('.mark');
          if(cb){ cb.checked = true; cb.disabled = true; saveSelection(); }
          btn.style.display = 'none';
          if(mark){ mark.style.display = 'inline'; }
        }else{
          alert('Eroare slskd: ' + (json.detail || 'necunoscută'));
          btn.disabled = false;
        }
      }catch(e){
        alert('Eroare rețea: ' + e);
        btn.disabled = false;
      }
    });
  }

  // --- Batch: Caută selectate (10s) ---
  btnBatch && btnBatch.addEventListener('click', async ()=>{
    if(!tracklist) return;
    const cbs = Array.from(tracklist.querySelectorAll('.sel:checked'))
                     .filter(cb => !cb.disabled);

    if(!cbs.length){ alert('Selectează cel puțin o melodie.'); return; }

    btnBatch.disabled = true;
    const intervalMs = 10000;
    let idx = 0;

    for(const cb of cbs){
      const li = cb.closest('.track-row');
      const q  = cb.getAttribute('data-query') || cb.value || '';
      if(statusEl) statusEl.textContent = `Trimit ${idx+1}/${cbs.length} ...`;

      try{
        const resp = await fetch('/slskd/search', {
          method: 'POST',
          headers: { 'Content-Type':'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ q })
        });
        const json = await resp.json();
        if(json && json.ok){
          cb.disabled = true;
          cb.checked  = true;
          saveSelection();

          const btn  = li.querySelector('.one-search-btn');
          const mark = li.querySelector('.mark');
          if(btn)  btn.style.display = 'none';
          if(mark) mark.style.display = 'inline';
        }
      }catch(e){
        console.error('Network error pentru', q, e);
      }

      idx++;
      if(idx < cbs.length){
        await new Promise(r => setTimeout(r, intervalMs));
      }
    }

    if(statusEl) statusEl.textContent = 'Gata.';
    setTimeout(()=> { if(statusEl){ statusEl.textContent = ''; }}, 3000);
    btnBatch.disabled = false;
  });

  // --- Init ---
  restoreSelection();
  applyFilter();

  document.addEventListener('change', e => {
    if(e.target && e.target.classList && e.target.classList.contains('sel')){
      saveSelection();
    }
  });
})();
</script>

{% endblock %}